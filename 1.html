<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>COSMIC DECISION ENGINE // 宇宙决策终端</title>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <style>
        /* ================= 全局样式系统 ================= */
        :root {
            --bg-light: #f4f4f7;
            --bg-dark: #000000;
            
            /* 卡片 - 浅色 */
            --card-bg-light: rgba(255, 255, 255, 0.75);
            --card-border-light: rgba(255, 255, 255, 0.9);
            --text-main-light: #1d1d1f;
            --text-sub-light: #86868b;
            --accent-light: #0071e3;

            /* 卡片 - 深色 (科幻) */
            --card-bg-dark: rgba(10, 10, 12, 0.5); /* 更通透，为了看清粒子 */
            --card-border-dark: rgba(255, 255, 255, 0.15);
            --text-main-dark: #ffffff;
            --text-sub-dark: #a1a1aa;
            --accent-dark: #40c9ff;

            --font-stack: "SF Pro Display", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --ease-out: cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; outline: none; -webkit-tap-highlight-color: transparent; }
        
        body {
            font-family: var(--font-stack);
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: var(--bg-light);
            transition: background-color 0.8s;
        }

        body[data-theme="dark"] {
            background-color: var(--bg-dark);
        }

        /* ================= 渲染层容器 ================= */
        #canvas-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 0;
            pointer-events: all; /* 允许拖动 */
        }
        
        /* 2D 浅色 Canvas */
        #light-canvas {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            opacity: 1;
            transition: opacity 1s;
        }
        
        /* 3D WebGL Canvas (Three.js) */
        #three-canvas {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            opacity: 0;
            transition: opacity 1s;
        }

        /* 主题显隐逻辑 */
        body[data-theme="light"] #light-canvas { opacity: 1; pointer-events: auto; }
        body[data-theme="light"] #three-canvas { opacity: 0; pointer-events: none; }
        
        body[data-theme="dark"] #light-canvas { opacity: 0; pointer-events: none; }
        body[data-theme="dark"] #three-canvas { opacity: 1; pointer-events: auto; }

        /* ================= UI 玻璃卡片 ================= */
        .glass-panel {
            position: relative;
            z-index: 10;
            width: 90%;
            max-width: 440px;
            min-height: 480px;
            background: var(--card-bg-light);
            backdrop-filter: blur(30px) saturate(180%);
            -webkit-backdrop-filter: blur(30px) saturate(180%);
            border: 1px solid var(--card-border-light);
            border-radius: 32px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
            padding: 2.5rem 2rem;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            transition: transform 0.4s var(--ease-out), background 0.5s, border 0.5s, box-shadow 0.5s;
        }

        /* 深色模式下的卡片样式 */
        body[data-theme="dark"] .glass-panel {
            background: var(--card-bg-dark);
            border-color: var(--card-border-dark);
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.6);
            color: var(--text-main-dark);
        }

        /* 悬停效果 (仅桌面) */
        @media (hover: hover) {
            .glass-panel:hover { transform: translateY(-6px); }
        }

        /* ================= 文字与内容排版 ================= */
        header {
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(128,128,128, 0.15);
        }

        h1 {
            font-size: 1.6rem;
            font-weight: 800;
            letter-spacing: -0.5px;
            margin-bottom: 0.3rem;
            display: flex;
            align-items: center;
            gap: 12px;
            color: var(--text-main-light);
        }
        body[data-theme="dark"] h1 { color: var(--text-main-dark); }

        .status-dot {
            width: 8px; height: 8px; 
            background: #30d158; 
            border-radius: 50%;
            box-shadow: 0 0 10px #30d158;
            animation: breathe 3s infinite;
        }

        .subtitle {
            font-size: 0.75rem;
            color: var(--text-sub-light);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1.5px;
        }
        body[data-theme="dark"] .subtitle { color: var(--text-sub-dark); }

        /* 内容区域 */
        .content-area {
            flex-grow: 1;
            position: relative;
            min-height: 240px;
        }

        /* 状态: 引导 */
        #state-intro {
            position: absolute;
            top: 50%; left: 0; right: 0;
            transform: translateY(-50%);
            text-align: center;
            transition: all 0.4s var(--ease-out);
            color: var(--text-main-light);
        }
        body[data-theme="dark"] #state-intro { color: var(--text-main-dark); }

        #state-intro.hidden {
            opacity: 0;
            transform: translateY(-20px);
            pointer-events: none;
        }

        .intro-icon {
            width: 48px; height: 48px;
            margin-bottom: 1rem;
            stroke: currentColor;
            opacity: 0.6;
            animation: float 4s ease-in-out infinite;
        }

        /* 状态: 结果 */
        #state-result {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            transform: translateY(10px);
        }

        #state-result.active {
            opacity: 1;
            pointer-events: auto;
            transform: translateY(0);
        }

        .data-row {
            display: flex;
            flex-direction: column;
            padding: 1rem 1.2rem;
            background: rgba(128, 128, 128, 0.05);
            border-radius: 16px;
            border: 1px solid transparent;
            transition: background 0.3s;
        }
        
        body[data-theme="dark"] .data-row { background: rgba(255, 255, 255, 0.05); }

        .label {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 1.2px;
            color: var(--text-sub-light);
            margin-bottom: 0.3rem;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        body[data-theme="dark"] .label { color: var(--text-sub-dark); }

        .value {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--text-main-light);
        }
        body[data-theme="dark"] .value { color: var(--text-main-dark); }

        /* 推荐品名高亮样式 */
        .data-row.highlight-row {
            background: rgba(0, 113, 227, 0.08);
            border-color: rgba(0, 113, 227, 0.2);
            display: none; /* 默认隐藏 */
        }
        body[data-theme="dark"] .data-row.highlight-row {
            background: rgba(64, 201, 255, 0.1);
            border-color: rgba(64, 201, 255, 0.3);
        }

        .data-row.highlight-row.show {
            display: flex;
            animation: slideUpFade 0.6s var(--ease-out) forwards;
        }

        .data-row.highlight-row .value {
            font-size: 1.6rem;
            font-weight: 800;
            background: linear-gradient(135deg, #0071e3, #42a5f5);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        body[data-theme="dark"] .data-row.highlight-row .value {
            background: linear-gradient(135deg, #40c9ff, #e028ce);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(64, 201, 255, 0.4);
        }

        /* ================= 按钮 ================= */
        .main-btn {
            width: 100%;
            height: 54px;
            border-radius: 27px;
            border: none;
            background: var(--text-main-light);
            color: var(--bg-light);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s var(--ease-out);
            position: relative;
            overflow: hidden;
            letter-spacing: 1px;
            margin-top: 1rem;
        }
        
        body[data-theme="dark"] .main-btn {
            background: #ffffff;
            color: #000000;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
        }

        .main-btn:hover { transform: scale(1.02); }
        .main-btn:active { transform: scale(0.97); }
        .main-btn:disabled { opacity: 0.6; cursor: not-allowed; }

        /* ================= 主题切换器 ================= */
        .theme-toggle {
            position: absolute;
            top: 2rem; right: 2rem;
            width: 44px; height: 44px;
            border-radius: 50%;
            background: rgba(128,128,128, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20;
            color: var(--text-main-light);
            transition: transform 0.3s, background 0.3s;
        }
        body[data-theme="dark"] .theme-toggle {
            color: #fff;
            background: rgba(255,255,255,0.1);
        }
        .theme-toggle:hover { transform: rotate(15deg) scale(1.1); }

        /* 遮罩动画 */
        .theme-overlay {
            position: fixed;
            top: 0; left: 0; width: 100vw; height: 100vh;
            background: #000;
            z-index: 9999;
            pointer-events: none;
            clip-path: circle(0% at 100% 0%);
            transition: clip-path 1s cubic-bezier(0.6, 0, 0.2, 1);
        }

        /* ================= 动画定义 ================= */
        @keyframes breathe { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.5; transform: scale(0.8); } }
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-6px); } }
        @keyframes slideUpFade { 
            0% { opacity: 0; transform: translateY(20px); } 
            100% { opacity: 1; transform: translateY(0); } 
        }

        .icon { width: 18px; height: 18px; stroke-width: 2; fill: none; stroke: currentColor; stroke-linecap: round; stroke-linejoin: round; }

    </style>
</head>
<body data-theme="light">

    <div id="canvas-container">
        <canvas id="light-canvas"></canvas>
        <div id="three-canvas"></div>
    </div>

    <div class="theme-overlay" id="theme-overlay"></div>

    <button class="theme-toggle" id="theme-btn" aria-label="Toggle Theme">
        </button>

    <main class="glass-panel">
        <header>
            <h1><div class="status-dot"></div> DECISION CORE</h1>
            <p class="subtitle">Quantum Probability Engine // v4.0</p>
        </header>

        <div class="content-area">
            <div id="state-intro">
                <svg class="intro-icon" viewBox="0 0 24 24"><path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2zm0 18a8 8 0 1 1 8-8 8 8 0 0 1-8 8z"></path><path d="M12 6v6l4 2"></path></svg>
                <p>INITIALIZING...<br><span style="font-size:0.8em; opacity:0.6;">WAITING FOR INPUT</span></p>
            </div>

            <div id="state-result">
                <div class="data-row">
                    <div class="label"><svg class="icon" viewBox="0 0 24 24"><path d="M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z"></path><circle cx="12" cy="10" r="3"></circle></svg> TARGET SECTOR</div>
                    <div class="value" id="val-canteen">---</div>
                </div>
                <div class="data-row">
                    <div class="label"><svg class="icon" viewBox="0 0 24 24"><path d="M3 3h18v18H3zM12 8v8M8 12h8"></path></svg> VENDOR ID</div>
                    <div class="value" id="val-shop">---</div>
                </div>
                <div class="data-row highlight-row" id="row-dish">
                    <div class="label"><svg class="icon" viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-5.82 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg> OPTIMAL CHOICE</div>
                    <div class="value" id="val-dish">---</div>
                </div>
            </div>
        </div>

        <button class="main-btn" id="start-btn">INITIATE SEQUENCE</button>
    </main>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        /* =================================================================
           第一部分：数据与业务逻辑 (Data & Logic)
           ================================================================= */
        const FOOD_DB = [
            { region: "第一食堂", shop: "西北面王", item: "红烧牛肉刀削面" },
            { region: "第一食堂", shop: "快乐汉堡", item: "双层香辣鸡腿堡" },
            { region: "第一食堂", shop: "自选快餐", item: "" }, 
            { region: "第二食堂", shop: "川湘小炒", item: "回锅肉盖饭" },
            { region: "第二食堂", shop: "麻辣烫", item: "" },
            { region: "商业街", shop: "瑞幸咖啡", item: "生椰拿铁 + 贝果" },
            { region: "商业街", shop: "7-Eleven", item: "好炖关东煮" },
            { region: "第三食堂", shop: "广式烧腊", item: "蜜汁叉烧饭" },
            { region: "第三食堂", shop: "铁板烧", item: "黑椒牛柳意面" },
            { region: "校外", shop: "麦当劳", item: "穷鬼套餐 (1+1)" }
        ];

        const UI = {
            btn: document.getElementById('start-btn'),
            intro: document.getElementById('state-intro'),
            resultBox: document.getElementById('state-result'),
            canteen: document.getElementById('val-canteen'),
            shop: document.getElementById('val-shop'),
            dishRow: document.getElementById('row-dish'),
            dish: document.getElementById('val-dish'),
            card: document.querySelector('.glass-panel')
        };

        let isRunning = false;
        let firstRun = true;

        UI.btn.addEventListener('click', () => {
            if (isRunning) return;
            startDecisionProcess();
        });

        function startDecisionProcess() {
            isRunning = true;
            UI.btn.disabled = true;
            UI.btn.innerText = "CALCULATING TRAJECTORY...";
            
            // 切换状态
            if (firstRun) {
                UI.intro.classList.add('hidden');
                setTimeout(() => {
                    UI.intro.style.display = 'none';
                    UI.resultBox.classList.add('active');
                }, 400);
                firstRun = false;
            }

            // 隐藏上一轮的具体品名
            UI.dishRow.classList.remove('show');

            let steps = 0;
            const maxSteps = 30;
            let speed = 30;

            function loop() {
                const pick = FOOD_DB[Math.floor(Math.random() * FOOD_DB.length)];
                
                // 滚动时只显示地点和店铺
                UI.canteen.innerText = pick.region;
                UI.shop.innerText = pick.shop;
                
                steps++;
                if (steps < maxSteps) {
                    speed += steps * 0.5; // 缓动减速
                    setTimeout(loop, speed);
                } else {
                    finalize(pick);
                }
            }
            loop();
        }

        function finalize(data) {
            isRunning = false;
            UI.btn.disabled = false;
            UI.btn.innerText = "RE-CALCULATE";
            
            UI.canteen.innerText = data.region;
            UI.shop.innerText = data.shop;

            // 只有存在品名时才显示第三行
            if (data.item && data.item.trim() !== "") {
                UI.dish.innerText = data.item;
                setTimeout(() => {
                    UI.dishRow.classList.add('show');
                }, 200);
            }

            // 视觉反馈
            UI.card.style.transform = "scale(1.02)";
            setTimeout(() => UI.card.style.transform = "scale(1)", 200);
        }

        /* =================================================================
           第二部分：浅色模式视觉 (Canvas 2D - 简约波浪)
           ================================================================= */
        const lightCanvas = document.getElementById('light-canvas');
        const lCtx = lightCanvas.getContext('2d');
        let lWidth, lHeight;
        let lParticles = [];

        function initLight() {
            lWidth = window.innerWidth;
            lHeight = window.innerHeight;
            lightCanvas.width = lWidth;
            lightCanvas.height = lHeight;
            lParticles = [];
            for (let i = 0; i < 60; i++) {
                lParticles.push({
                    x: Math.random() * lWidth,
                    y: Math.random() * lHeight,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: (Math.random() - 0.5) * 0.5
                });
            }
        }

        function animateLight() {
            if (document.body.getAttribute('data-theme') !== 'light') return;
            
            lCtx.clearRect(0, 0, lWidth, lHeight);
            lCtx.fillStyle = '#1d1d1f';
            
            for (let i = 0; i < lParticles.length; i++) {
                let p = lParticles[i];
                p.x += p.vx; p.y += p.vy;
                if(p.x<0 || p.x>lWidth) p.vx*=-1;
                if(p.y<0 || p.y>lHeight) p.vy*=-1;
                
                lCtx.beginPath();
                lCtx.arc(p.x, p.y, 2, 0, Math.PI*2);
                lCtx.fillStyle = "rgba(0,0,0,0.15)";
                lCtx.fill();

                for(let j=i+1; j<lParticles.length; j++){
                    let p2 = lParticles[j];
                    let dx = p.x-p2.x, dy=p.y-p2.y;
                    let dist = dx*dx+dy*dy;
                    if(dist < 15000) {
                        lCtx.beginPath();
                        lCtx.moveTo(p.x, p.y);
                        lCtx.lineTo(p2.x, p2.y);
                        lCtx.strokeStyle = `rgba(0,0,0,${0.08 - dist/15000})`;
                        lCtx.stroke();
                    }
                }
            }
            requestAnimationFrame(animateLight);
        }

        /* =================================================================
           第三部分：深色模式视觉 (Three.js - 宏大宇宙数学粒子)
           ================================================================= */
        // 配置
        const PARTICLE_COUNT = 30000;
        const GALAXY_SIZE = 1200;
        
        // 全局变量
        let scene, camera, renderer, composer;
        let particles, geometry, materials;
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;
        
        // 粒子目标位置存储 (用于形态变换)
        const positions = []; // 当前
        const targets = {
            sphere: [],
            helix: [], // 阿基米德/旋涡
            rose: [],
            lemniscate: [] // 双纽线
        };
        let currentTarget = 'helix'; // 当前形态
        let transitionProgress = 0;
        let lastMorphTime = 0;
        const morphDuration = 10000; // 10秒变换一次

        function initThree() {
            const container = document.getElementById('three-canvas');
            
            // 1. 场景与相机
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.0006);

            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 1, 5000);
            camera.position.z = 1000;

            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            container.appendChild(renderer.domElement);

            // 2. 后期处理 (Bloom 辉光)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.1;
            bloomPass.strength = 1.2; // 辉光强度
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // 3. 粒子生成
            generateParticles();
            generateMathTargets();

            // 4. 事件监听
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousemove', onDocumentMouseMove);
            
            // 开启渲染循环
            animateThree();
        }

        // 生成粒子几何体
        function generateParticles() {
            geometry = new THREE.BufferGeometry();
            const posArray = new Float32Array(PARTICLE_COUNT * 3);
            const colorArray = new Float32Array(PARTICLE_COUNT * 3);
            const sizes = new Float32Array(PARTICLE_COUNT);

            const color1 = new THREE.Color(0x40c9ff); // 蓝
            const color2 = new THREE.Color(0xe028ce); // 紫

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                // 初始随机位置
                const x = (Math.random() - 0.5) * GALAXY_SIZE * 3;
                const y = (Math.random() - 0.5) * GALAXY_SIZE * 3;
                const z = (Math.random() - 0.5) * GALAXY_SIZE * 3;

                posArray[i * 3] = x;
                posArray[i * 3 + 1] = y;
                posArray[i * 3 + 2] = z;

                // 颜色混插
                const mixedColor = color1.clone().lerp(color2, Math.random());
                colorArray[i * 3] = mixedColor.r;
                colorArray[i * 3 + 1] = mixedColor.g;
                colorArray[i * 3 + 2] = mixedColor.b;

                sizes[i] = Math.random() * 2;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            // 粒子材质 (模拟发光点)
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    color: { value: new THREE.Color(0xffffff) }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    void main() {
                        // 圆形粒子
                        float r = distance(gl_PointCoord, vec2(0.5, 0.5));
                        if (r > 0.5) discard;
                        // 辉光核心
                        float strength = 1.0 - (r * 2.0);
                        gl_FragColor = vec4(vColor, strength);
                    }
                `,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // 计算不同形态的目标坐标
        function generateMathTargets() {
            // 1. 球体 (Chaos/Sphere)
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                const r = 800;
                targets.sphere.push(
                    r * Math.cos(theta) * Math.sin(phi),
                    r * Math.sin(theta) * Math.sin(phi),
                    r * Math.cos(phi)
                );
            }

            // 2. 旋涡 / 阿基米德螺旋 (Helix)
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const theta = i * 0.005; // 紧密度
                const r = 5 + 0.3 * theta; // 扩散度
                // 加上厚度干扰
                const x = (r * 15) * Math.cos(theta);
                const y = (Math.random() - 0.5) * 200; 
                const z = (r * 15) * Math.sin(theta);
                targets.helix.push(x, y, z);
            }

            // 3. 伯努利双纽线 (Lemniscate)
            // (x^2 + y^2)^2 = 2a^2(x^2 - y^2) -> Parametric: x = a*cos(t)/(1+sin^2(t)), y = a*sin(t)cos(t)/(1+sin^2(t))
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const t = (i / PARTICLE_COUNT) * Math.PI * 20; // 绕多圈
                const a = 1200;
                const denom = 1 + Math.sin(t)**2;
                const x = (a * Math.cos(t)) / denom;
                const y = (Math.random() - 0.5) * 300; // 厚度
                const z = (a * Math.sin(t) * Math.cos(t)) / denom;
                targets.lemniscate.push(x, y, z);
            }

            // 4. 玫瑰曲线 (Rose Curve) - k=4
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const k = 4;
                const theta = (i / PARTICLE_COUNT) * Math.PI * 12;
                const r = 1000 * Math.cos(k * theta);
                const x = r * Math.cos(theta);
                const y = r * Math.sin(theta);
                const z = (Math.random() - 0.5) * 400; // Z轴厚度
                targets.rose.push(x, y, z);
            }
        }

        // 鼠标交互
        function onDocumentMouseMove(event) {
            mouseX = (event.clientX - window.innerWidth / 2) * 0.2;
            mouseY = (event.clientY - window.innerHeight / 2) * 0.2;
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            initLight(); // 重置浅色Canvas
        }

        // 动画循环
        function animateThree() {
            requestAnimationFrame(animateThree);
            
            // 只有深色模式渲染
            const isDark = document.body.getAttribute('data-theme') === 'dark';
            if (!isDark) return;

            // 1. 摄像机跟随鼠标 (平滑阻尼)
            targetRotationX += (mouseX - targetRotationX) * 0.05;
            targetRotationY += (-mouseY - targetRotationY) * 0.05;
            
            // 粒子整体旋转
            particles.rotation.y += 0.002; // 自转
            particles.rotation.x += (mouseY * 0.0001);
            particles.rotation.y += (mouseX * 0.0001);

            // 2. 形态变换逻辑 (Morphing)
            const time = Date.now();
            if (time - lastMorphTime > morphDuration) {
                lastMorphTime = time;
                const keys = Object.keys(targets);
                currentTarget = keys[Math.floor(Math.random() * keys.length)];
            }

            // 3. 粒子插值移动 (Lerp)
            const positionsAttribute = geometry.attributes.position;
            const currentPositions = positionsAttribute.array;
            const targetPositions = targets[currentTarget];

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                // 简单的弹性移动算法
                currentPositions[ix] += (targetPositions[ix] - currentPositions[ix]) * 0.03;
                currentPositions[iy] += (targetPositions[iy] - currentPositions[iy]) * 0.03;
                currentPositions[iz] += (targetPositions[iz] - currentPositions[iz]) * 0.03;
            }
            positionsAttribute.needsUpdate = true;

            // 4. 渲染后期
            composer.render();
        }


        /* =================================================================
           第四部分：主题与启动 (Main)
           ================================================================= */
        const themeBtn = document.getElementById('theme-btn');
        const themeOverlay = document.getElementById('theme-overlay');
        const svgSun = `<svg class="icon" viewBox="0 0 24 24"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>`;
        const svgMoon = `<svg class="icon" viewBox="0 0 24 24"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>`;

        let currentTheme = 'light';

        // 切换逻辑
        themeBtn.addEventListener('click', () => {
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            
            // 遮罩位置计算
            const rect = themeBtn.getBoundingClientRect();
            const x = (rect.left + rect.width/2) / window.innerWidth * 100;
            const y = (rect.top + rect.height/2) / window.innerHeight * 100;

            themeOverlay.style.clipPath = `circle(0% at ${x}% ${y}%)`;
            themeOverlay.style.background = newTheme === 'dark' ? '#000' : '#f4f4f7';
            
            // 执行动画
            requestAnimationFrame(() => {
                themeOverlay.style.clipPath = `circle(150% at ${x}% ${y}%)`;
            });

            setTimeout(() => {
                currentTheme = newTheme;
                document.body.setAttribute('data-theme', newTheme);
                themeBtn.innerHTML = newTheme === 'dark' ? svgSun : svgMoon;
                
                // 启动或暂停相应渲染循环以节省资源
                if (newTheme === 'dark') {
                    if(!scene) initThree(); // 懒加载3D场景
                }
                if (newTheme === 'light') {
                    animateLight();
                }

            }, 500);

            setTimeout(() => {
                themeOverlay.style.clipPath = `circle(0% at ${x}% ${y}%)`;
            }, 1000);
        });

        // 初始化
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            currentTheme = 'dark';
            document.body.setAttribute('data-theme', 'dark');
            themeBtn.innerHTML = svgSun;
            initThree();
        } else {
            themeBtn.innerHTML = svgMoon;
            initLight();
            animateLight();
        }

    </script>
</body>
</html>